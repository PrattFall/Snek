
==================== FINAL INTERFACE ====================
2016-03-24 07:30:46.438517 UTC

interface snake_Fl2eL9xvVIkFKyiu4RtRAc:Snek 7103
  interface hash: 41978573b19844b8a41228e1be78b3b0
  ABI hash: 568a5c9340a430ee21071e539fafe3f3
  export-list hash: 926b1e0cdb0e1c3809ecdfc3a089af33
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 4c0a7b65a6dddbc4161c2e2bfabe3dc3
  sig of: Nothing
  used TH splices: False
  where
exports:
  Snek.addSnakeBit
  Snek.createMap
  Snek.displayMap
  Snek.moveSnake
  Snek.pointsOverlap
  Snek.snakeAteSelf
  Snek.turnSnake
  Snek.Direction{Snek.E Snek.N Snek.S Snek.W}
  Snek.Food
  Snek.GameMap{Snek.GameMap}
  Snek.MapSize{Snek.MapSize}
  Snek.Point{Snek.Point}
  Snek.Snake{Snek.Snake}
  Snek.SnakeBit
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
9a45aeefd7be9f5456a396405febb2f6
  $fEqDirection :: GHC.Classes.Eq Snek.Direction
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Snek.Direction Snek.$fEqDirection_$c== Snek.$fEqDirection_$c/= -}
9a45aeefd7be9f5456a396405febb2f6
  $fEqDirection_$c/= ::
    Snek.Direction -> Snek.Direction -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: Snek.Direction b :: Snek.Direction ->
                 case a of wild {
                   Snek.N
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Snek.N -> GHC.Types.False }
                   Snek.E
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Snek.E -> GHC.Types.False }
                   Snek.S
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Snek.S -> GHC.Types.False }
                   Snek.W
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Snek.W -> GHC.Types.False } }) -}
9a45aeefd7be9f5456a396405febb2f6
  $fEqDirection_$c== ::
    Snek.Direction -> Snek.Direction -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: Snek.Direction ds1 :: Snek.Direction ->
                 case ds of wild {
                   Snek.N
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Snek.N -> GHC.Types.True }
                   Snek.E
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Snek.E -> GHC.Types.True }
                   Snek.S
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Snek.S -> GHC.Types.True }
                   Snek.W
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Snek.W -> GHC.Types.True } }) -}
efc9bb1d1450375b916b9095d2b48519
  $fEqPoint :: GHC.Classes.Eq Snek.Point
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Snek.Point Snek.$fEqPoint_$c== Snek.$fEqPoint_$c/= -}
efc9bb1d1450375b916b9095d2b48519
  $fEqPoint_$c/= :: Snek.Point -> Snek.Point -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U(U))><S(SL),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Snek.Point w1 :: Snek.Point ->
                 case w of ww { Snek.Point ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Snek.Point ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Snek.$w$c/= ww4 ww2 ww9 ww7 } } } }) -}
efc9bb1d1450375b916b9095d2b48519
  $fEqPoint_$c== :: Snek.Point -> Snek.Point -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U),1*U(U))><S(SL),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Snek.Point w1 :: Snek.Point ->
                 case w of ww { Snek.Point ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Snek.Point ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Snek.$w$c== ww4 ww2 ww9 ww7 } } } }) -}
9a45aeefd7be9f5456a396405febb2f6
  $fShowDirection :: GHC.Show.Show Snek.Direction
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Snek.Direction
                  Snek.$fShowDirection_$cshowsPrec
                  Snek.$fShowDirection_$cshow
                  Snek.$fShowDirection_$cshowList -}
3b5dea75bfd03a35807269a5a7cf4261
  $fShowDirection1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "W"#) -}
910ba34218f0370c030976f72fda53ff
  $fShowDirection2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "S"#) -}
e431835c1495310eb36303e9944ff808
  $fShowDirection3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "E"#) -}
2c3708f8c18716a723089f579243de3e
  $fShowDirection4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "N"#) -}
9a45aeefd7be9f5456a396405febb2f6
  $fShowDirection_$cshow :: Snek.Direction -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Snek.Direction ->
                 Snek.$fShowDirection_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
9a45aeefd7be9f5456a396405febb2f6
  $fShowDirection_$cshowList :: [Snek.Direction] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Snek.Direction
                   Snek.$w$cshowsPrec) -}
9a45aeefd7be9f5456a396405febb2f6
  $fShowDirection_$cshowsPrec ::
    GHC.Types.Int -> Snek.Direction -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int w1 :: Snek.Direction w2 :: GHC.Base.String ->
                 Snek.$w$cshowsPrec w1 w2) -}
4a5d1d1ac2164e08576480c3e3190acb
  $fShowGameMap :: GHC.Show.Show Snek.GameMap
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Snek.GameMap
                  Snek.$fShowGameMap_$cshowsPrec
                  Snek.$fShowGameMap_$cshow
                  Snek.$fShowGameMap_$cshowList -}
4a5d1d1ac2164e08576480c3e3190acb
  $fShowGameMap1 :: Snek.GameMap -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Snek.GameMap w1 :: GHC.Base.String ->
                 case w of ww { Snek.GameMap ww1 ww2 ->
                 Snek.$w$cshowsPrec1 0 ww1 ww2 w1 }) -}
780cb920158c6e450db507ce0317aa1a
  $fShowGameMap2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MapSize "#) -}
5a583bd336297b485f369869803638dc
  $fShowGameMap3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GameMap "#) -}
4a5d1d1ac2164e08576480c3e3190acb
  $fShowGameMap_$cshow :: Snek.GameMap -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(1*U(U),1*U(U)),1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Snek.GameMap ->
                 Snek.$fShowGameMap_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
4a5d1d1ac2164e08576480c3e3190acb
  $fShowGameMap_$cshowList :: [Snek.GameMap] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Snek.GameMap
                   Snek.$fShowGameMap1) -}
4a5d1d1ac2164e08576480c3e3190acb
  $fShowGameMap_$cshowsPrec ::
    GHC.Types.Int -> Snek.GameMap -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <S,1*U(U)><S,1*U(1*U(1*U(U),1*U(U)),1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Snek.GameMap w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Snek.GameMap ww3 ww4 ->
                 Snek.$w$cshowsPrec1 ww1 ww3 ww4 w2 } }) -}
de9717a62c5544906313650d4ee54494
  $fShowMapSize :: GHC.Show.Show Snek.MapSize
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Snek.MapSize
                  Snek.$fShowMapSize_$cshowsPrec
                  Snek.$fShowMapSize_$cshow
                  Snek.$fShowMapSize_$cshowList -}
de9717a62c5544906313650d4ee54494
  $fShowMapSize1 :: Snek.MapSize -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Snek.MapSize w1 :: GHC.Base.String ->
                 case w of ww { Snek.MapSize ww1 ww2 ->
                 Snek.$w$cshowsPrec2 0 ww1 ww2 w1 }) -}
de9717a62c5544906313650d4ee54494
  $fShowMapSize_$cshow :: Snek.MapSize -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(U),1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Snek.MapSize ->
                 Snek.$fShowMapSize_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
de9717a62c5544906313650d4ee54494
  $fShowMapSize_$cshowList :: [Snek.MapSize] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Snek.MapSize
                   Snek.$fShowMapSize1) -}
de9717a62c5544906313650d4ee54494
  $fShowMapSize_$cshowsPrec ::
    GHC.Types.Int -> Snek.MapSize -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U(U),1*U(U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Snek.MapSize w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Snek.MapSize ww3 ww4 ->
                 Snek.$w$cshowsPrec2 ww1 ww3 ww4 w2 } }) -}
efc9bb1d1450375b916b9095d2b48519
  $fShowPoint :: GHC.Show.Show Snek.Point
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Snek.Point
                  Snek.$fShowPoint_$cshowsPrec
                  Snek.$fShowPoint_$cshow
                  Snek.$fShowPoint_$cshowList -}
efc9bb1d1450375b916b9095d2b48519
  $fShowPoint1 :: Snek.Point -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Snek.Point w1 :: GHC.Base.String ->
                 case w of ww { Snek.Point ww1 ww2 ->
                 Snek.$w$cshowsPrec3 0 ww1 ww2 w1 }) -}
f4eb5d7487f4650693739a19c30c84f6
  $fShowPoint2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Point "#) -}
efc9bb1d1450375b916b9095d2b48519
  $fShowPoint_$cshow :: Snek.Point -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(U),1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Snek.Point ->
                 Snek.$fShowPoint_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
efc9bb1d1450375b916b9095d2b48519
  $fShowPoint_$cshowList :: [Snek.Point] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ Snek.Point Snek.$fShowPoint1) -}
efc9bb1d1450375b916b9095d2b48519
  $fShowPoint_$cshowsPrec ::
    GHC.Types.Int -> Snek.Point -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U(U),1*U(U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Snek.Point w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Snek.Point ww3 ww4 ->
                 Snek.$w$cshowsPrec3 ww1 ww3 ww4 w2 } }) -}
14e6744acbb649b50c1230ae50630abf
  $fShowSnake :: GHC.Show.Show Snek.Snake
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Snek.Snake
                  Snek.$fShowSnake_$cshowsPrec
                  Snek.$fShowSnake_$cshow
                  Snek.$fShowSnake_$cshowList -}
14e6744acbb649b50c1230ae50630abf
  $fShowSnake1 :: Snek.Snake -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Snek.Snake w1 :: GHC.Base.String ->
                 case w of ww { Snek.Snake ww1 ww2 ->
                 Snek.$w$cshowsPrec4 0 ww1 ww2 w1 }) -}
854bd071032701b68bd6b38a11237b9e
  $fShowSnake2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Snake "#) -}
14e6744acbb649b50c1230ae50630abf
  $fShowSnake_$cshow :: Snek.Snake -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Snek.Snake ->
                 Snek.$fShowSnake_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
14e6744acbb649b50c1230ae50630abf
  $fShowSnake_$cshowList :: [Snek.Snake] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ Snek.Snake Snek.$fShowSnake1) -}
14e6744acbb649b50c1230ae50630abf
  $fShowSnake_$cshowsPrec ::
    GHC.Types.Int -> Snek.Snake -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Snek.Snake w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Snek.Snake ww3 ww4 ->
                 Snek.$w$cshowsPrec4 ww1 ww3 ww4 w2 } }) -}
5af98c4aee6b4831da5b87677479949d
  $w$c/= ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Types.Int
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Types.Int ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Types.I# x ->
                      case ww3 of wild2 { GHC.Types.I# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x y) of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
9d7483adb71a5013c532b887b6fd9baf
  $w$c== ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Types.Int
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Types.Int ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> GHC.Classes.eqInt ww1 ww3 }) -}
9a45aeefd7be9f5456a396405febb2f6
  $w$cshowsPrec ::
    Snek.Direction -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: Snek.Direction w1 :: GHC.Base.String ->
                 case w of wild {
                   Snek.N -> GHC.Base.++ @ GHC.Types.Char Snek.$fShowDirection4 w1
                   Snek.E -> GHC.Base.++ @ GHC.Types.Char Snek.$fShowDirection3 w1
                   Snek.S -> GHC.Base.++ @ GHC.Types.Char Snek.$fShowDirection2 w1
                   Snek.W
                   -> GHC.Base.++ @ GHC.Types.Char Snek.$fShowDirection1 w1 }) -}
6e69acd12ea023b9e5f24602d6361702
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> Snek.MapSize
    -> [Snek.MapRow]
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U><L,1*U(1*U(U),1*U(U))><L,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: Snek.MapSize
                   ww2 :: [Snek.MapRow]
                   w :: GHC.Base.String ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Snek.$fShowGameMap3
                       (case ww1 of ww3 { Snek.MapSize ww4 ww5 ->
                        Snek.$w$cshowsPrec2
                          11
                          ww4
                          ww5
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (GHC.Show.showList__
                                @ [GHC.Base.String]
                                GHC.Show.shows_$s$cshowList
                                ww2
                                x)) })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w)) }) -}
7b22a659a5d5fddb68e425444b424233
  $w$cshowsPrec2 ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U><L,1*U(U)><L,1*U(U)><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Types.Int
                   ww2 :: GHC.Types.Int
                   w :: GHC.Base.String ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     case ww1 of ww3 { GHC.Types.I# ww4 ->
                     case GHC.Show.$wshowSignedInt
                            11
                            ww4
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (case ww2 of ww5 { GHC.Types.I# ww6 ->
                                case GHC.Show.$wshowSignedInt 11 ww6 x of ww7 { (#,#) ww8 ww9 ->
                                GHC.Types.:
                                  @ GHC.Types.Char
                                  ww8
                                  ww9 } })) of ww5 { (#,#) ww6 ww7 ->
                     GHC.Types.: @ GHC.Types.Char ww6 ww7 } }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++ @ GHC.Types.Char Snek.$fShowGameMap2 (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Snek.$fShowGameMap2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))) }) -}
d85815f7bf49b6797d82acb3d2771ff4
  $w$cshowsPrec3 ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U><L,1*U(U)><L,1*U(U)><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Types.Int
                   ww2 :: GHC.Types.Int
                   w :: GHC.Base.String ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     case ww1 of ww3 { GHC.Types.I# ww4 ->
                     case GHC.Show.$wshowSignedInt
                            11
                            ww4
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (case ww2 of ww5 { GHC.Types.I# ww6 ->
                                case GHC.Show.$wshowSignedInt 11 ww6 x of ww7 { (#,#) ww8 ww9 ->
                                GHC.Types.:
                                  @ GHC.Types.Char
                                  ww8
                                  ww9 } })) of ww5 { (#,#) ww6 ww7 ->
                     GHC.Types.: @ GHC.Types.Char ww6 ww7 } }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++ @ GHC.Types.Char Snek.$fShowPoint2 (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Snek.$fShowPoint2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))) }) -}
96b46890842b7bee9b265a64b00354f3
  $w$cshowsPrec4 ::
    GHC.Prim.Int#
    -> Snek.Direction
    -> [Snek.SnakeBit]
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U><L,1*U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: Snek.Direction
                   ww2 :: [Snek.SnakeBit]
                   w :: GHC.Base.String ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Snek.$fShowSnake2
                        (Snek.$w$cshowsPrec
                           ww1
                           (GHC.Types.:
                              @ GHC.Types.Char
                              GHC.Show.showSpace1
                              (GHC.Show.showList__ @ Snek.Point Snek.$fShowPoint1 ww2 w)))
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Snek.$fShowSnake2
                           (Snek.$w$cshowsPrec
                              ww1
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.showSpace1
                                 (GHC.Show.showList__
                                    @ Snek.Point
                                    Snek.$fShowPoint1
                                    ww2
                                    (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))))) }) -}
4a7d47d80bcfb9db31a516605123fa7c
  $wcreateMap ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> [Snek.SnakeBit]
    -> Snek.Food
    -> (# Snek.MapSize, [Snek.MapRow] #)
  {- Arity: 4, Strictness: <L,U(U)><L,U(U)><L,U><L,U(U(U),U(U))>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Types.Int
                   ww1 :: GHC.Types.Int
                   ww2 :: [Snek.SnakeBit]
                   w :: Snek.Food ->
                 (# Snek.MapSize ww ww1,
                    case ww1 of wild { GHC.Types.I# x ->
                    let {
                      y :: GHC.Prim.Int# = GHC.Prim.-# x 1
                    } in
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.># 0 y) of wild1 {
                      GHC.Types.False
                      -> let {
                           lvl :: [GHC.Types.Int]
                           = case ww of wild2 { GHC.Types.I# x1 ->
                             GHC.Enum.eftInt 0 (GHC.Prim.-# x1 1) }
                         } in
                         letrec {
                           go1 :: GHC.Prim.Int# -> [Snek.MapRow]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ x1 :: GHC.Prim.Int# ->
                             GHC.Types.:
                               @ Snek.MapRow
                               (let {
                                  ds :: GHC.Types.Int {- Strictness: m -} = GHC.Types.I# x1
                                } in
                                letrec {
                                  go2 :: [GHC.Types.Int] -> [Snek.Cell]
                                    {- Arity: 1, Strictness: <S,1*U> -}
                                  = \ ds1 :: [GHC.Types.Int] ->
                                    case ds1 of wild2 {
                                      [] -> GHC.Types.[] @ Snek.Cell
                                      : y1 ys
                                      -> GHC.Types.:
                                           @ Snek.Cell
                                           (case w of wild3 { Snek.Point b1 b2 ->
                                            case y1 of wild4 { GHC.Types.I# x2 ->
                                            case b1 of wild5 { GHC.Types.I# y2 ->
                                            case GHC.Prim.tagToEnum#
                                                   @ GHC.Types.Bool
                                                   (GHC.Prim.==# x2 y2) of wild6 {
                                              GHC.Types.False
                                              -> case Snek.pointsOverlap
                                                        ww2
                                                        (Snek.Point wild4 ds) of wild7 {
                                                   GHC.Types.False -> Snek.createMap2
                                                   GHC.Types.True -> Snek.$fShowDirection2 }
                                              GHC.Types.True
                                              -> case b2 of wild7 { GHC.Types.I# y3 ->
                                                 case GHC.Prim.tagToEnum#
                                                        @ GHC.Types.Bool
                                                        (GHC.Prim.==# x1 y3) of wild8 {
                                                   GHC.Types.False
                                                   -> case Snek.pointsOverlap
                                                             ww2
                                                             (Snek.Point wild4 ds) of wild9 {
                                                        GHC.Types.False -> Snek.createMap2
                                                        GHC.Types.True -> Snek.$fShowDirection2 }
                                                   GHC.Types.True -> Snek.createMap1 } } } } } })
                                           (go2 ys) }
                                } in
                                go2 lvl)
                               (case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==# x1 y) of wild2 {
                                  GHC.Types.False -> go1 (GHC.Prim.+# x1 1)
                                  GHC.Types.True -> GHC.Types.[] @ Snek.MapRow })
                         } in
                         go1 0
                      GHC.Types.True -> GHC.Types.[] @ Snek.MapRow } } #)) -}
5b60f37ae46b284a1f42cebb7607c086
  $wsnakeAteSelf :: [Snek.SnakeBit] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
0c2d20917882130b295a4ca483f59d1e
  type Cell = GHC.Base.String
9a45aeefd7be9f5456a396405febb2f6
  data Direction = N | E | S | W
    Promotable
2761b2ce3503b4e71ab4aa655a48d7c5
  type Food = Snek.Point
4a5d1d1ac2164e08576480c3e3190acb
  data GameMap = GameMap Snek.MapSize [Snek.MapRow]
ccd61c745dcd77e66801bf1adc11f50f
  type MapRow = [Snek.Cell]
de9717a62c5544906313650d4ee54494
  data MapSize = MapSize GHC.Types.Int GHC.Types.Int
efc9bb1d1450375b916b9095d2b48519
  data Point = Point GHC.Types.Int GHC.Types.Int
14e6744acbb649b50c1230ae50630abf
  data Snake = Snake Snek.Direction [Snek.SnakeBit]
19bb9f8e548da2e496406b088ff5fe26
  type SnakeBit = Snek.Point
b53e64850b794722e24fccfc80350833
  addSnakeBit :: Snek.Snake -> Snek.Snake
  {- Arity: 1, Strictness: <S,1*U(U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Snek.Snake ->
                 case ds of wild { Snek.Snake dir sb ->
                 Snek.Snake
                   dir
                   (GHC.Types.:
                      @ Snek.SnakeBit
                      (Snek.newHead (Snek.Snake dir sb))
                      sb) }) -}
f9b9a2e8a6f687091472dbe76199e15d
  createMap ::
    Snek.MapSize -> Snek.Snake -> Snek.Food -> Snek.GameMap
  {- Arity: 3,
     Strictness: <S,1*U(U(U),U(U))><S,1*U(A,U)><L,U(U(U),U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: Snek.MapSize w1 :: Snek.Snake w2 :: Snek.Food ->
                 case w of ww { Snek.MapSize ww1 ww2 ->
                 case w1 of ww3 { Snek.Snake ww4 ww5 ->
                 case Snek.$wcreateMap ww1 ww2 ww5 w2 of ww6 { (#,#) ww7 ww8 ->
                 Snek.GameMap ww7 ww8 } } }) -}
da20d8bf064303a54c344262675d65f9
  createMap1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "F"#) -}
56990fc5f4c09cbdfe9aa8998ce3a6d0
  createMap2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "."#) -}
bf1adb67d62d3af9199b3b5fc10ce691
  displayMap :: Snek.GameMap -> GHC.Base.String
  {- Arity: 1, Strictness: <S(SS),1*U(1*H,1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: Snek.GameMap ->
                 case w of ww { Snek.GameMap ww1 ww2 ->
                 case ww1 of ww3 { Snek.MapSize ipv ipv1 ->
                 Snek.displayMap_go ww2 } }) -}
2a5bf841b1a9324c29a87d2e65904a28
  displayMap_go :: [[[GHC.Types.Char]]] -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U> -}
254e4d96664e93d4d5aff29ce38f6597
  moveSnake :: Snek.Snake -> Snek.Snake
  {- Arity: 1, Strictness: <S,1*U(U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Snek.Snake ->
                 case ds of wild { Snek.Snake dir sb ->
                 Snek.Snake
                   dir
                   (GHC.Types.:
                      @ Snek.SnakeBit
                      (Snek.newHead (Snek.Snake dir sb))
                      (GHC.List.init @ Snek.SnakeBit sb)) }) -}
0b918948f608320166fb6db252a3768e
  newHead :: Snek.Snake -> Snek.SnakeBit
  {- Arity: 1, Strictness: <S(SS),1*U(1*U,1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: Snek.Snake ->
                 case w of ww { Snek.Snake ww1 ww2 ->
                 case ww2 of wild {
                   [] -> case GHC.List.badHead ret_ty Snek.Point of {}
                   : x ds1
                   -> case x of wild1 { Snek.Point x1 y ->
                      case ww1 of wild2 {
                        Snek.N
                        -> Snek.Point
                             x1
                             (case y of wild3 { GHC.Types.I# x2 ->
                              GHC.Types.I# (GHC.Prim.-# x2 1) })
                        Snek.E
                        -> Snek.Point
                             (case x1 of wild3 { GHC.Types.I# x2 ->
                              GHC.Types.I# (GHC.Prim.+# x2 1) })
                             y
                        Snek.S
                        -> Snek.Point
                             x1
                             (case y of wild3 { GHC.Types.I# x2 ->
                              GHC.Types.I# (GHC.Prim.+# x2 1) })
                        Snek.W
                        -> Snek.Point
                             (case x1 of wild3 { GHC.Types.I# x2 ->
                              GHC.Types.I# (GHC.Prim.-# x2 1) })
                             y } } } }) -}
fecdbdefa4a55baa02c7d9468cc3b90d
  pointsOverlap :: [Snek.Point] -> Snek.Point -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U(U(U),U(U))>,
     Unfolding: (\ pts :: [Snek.Point] tgt :: Snek.Point ->
                 letrec {
                   go1 :: [Snek.Point] -> GHC.Types.Bool -> GHC.Types.Bool
                     {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                   = \ ds :: [Snek.Point] eta :: GHC.Types.Bool ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> go1
                            ys
                            (case y of wild1 { Snek.Point a1 a2 ->
                             case tgt of wild2 { Snek.Point b1 b2 ->
                             case a1 of wild3 { GHC.Types.I# x ->
                             case b1 of wild4 { GHC.Types.I# y1 ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.==# x y1) of wild5 {
                               GHC.Types.False -> eta
                               GHC.Types.True
                               -> case a2 of wild6 { GHC.Types.I# x1 ->
                                  case b2 of wild7 { GHC.Types.I# y2 ->
                                  case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.==# x1 y2) of wild8 {
                                    GHC.Types.False -> eta
                                    GHC.Types.True -> GHC.Types.True } } } } } } } }) }
                 } in
                 go1 pts GHC.Types.False) -}
c2cb8e382645447d0b8e80652c2f88da
  snakeAteSelf :: Snek.Snake -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: Snek.Snake ->
                 case w of ww { Snek.Snake ww1 ww2 -> Snek.$wsnakeAteSelf ww2 }) -}
7a76706fdae28db67dc2984f9476ec73
  turnSnake :: Snek.Snake -> Snek.Direction -> Snek.Snake
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(A,U)><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Snek.Snake dir :: Snek.Direction ->
                 case ds of wild { Snek.Snake ds1 sb -> Snek.Snake dir sb }) -}
instance GHC.Classes.Eq [Snek.Direction] = Snek.$fEqDirection
instance GHC.Classes.Eq [Snek.Point] = Snek.$fEqPoint
instance GHC.Show.Show [Snek.Direction] = Snek.$fShowDirection
instance GHC.Show.Show [Snek.GameMap] = Snek.$fShowGameMap
instance GHC.Show.Show [Snek.MapSize] = Snek.$fShowMapSize
instance GHC.Show.Show [Snek.Point] = Snek.$fShowPoint
instance GHC.Show.Show [Snek.Snake] = Snek.$fShowSnake
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

